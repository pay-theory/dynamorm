# DynamORM v1.0.1 Release Notes - Interface-Based Design for Improved Testability

**Release Date**: December 20, 2024

## Overview

DynamORM v1.0.1 introduces a significant architectural improvement: an interface-based design that dramatically improves testability while maintaining backward compatibility for most use cases. This release makes it possible to write comprehensive unit tests for your DynamoDB-backed services without requiring a real database connection.

## Key Features

### 1. Interface-Based Architecture

DynamORM now provides two main interfaces:

- **`core.DB`** - Basic interface with core CRUD operations
- **`core.ExtendedDB`** - Full interface including schema management

```go
// Before v1.0.1
var db *dynamorm.DB

// After v1.0.1
var db core.ExtendedDB  // For full functionality
var db core.DB          // For basic operations only
```

### 2. Improved Testability

You can now easily mock DynamORM in your unit tests:

```go
// In your service
type UserService struct {
    db core.DB  // Use interface instead of concrete type
}

// In your tests
mockDB := new(MockDB)
service := &UserService{db: mockDB}
```

### 3. New Constructor Functions

- `dynamorm.New()` - Returns `core.ExtendedDB` (full functionality)
- `dynamorm.NewBasic()` - Returns `core.DB` (basic operations only)

## Breaking Changes

### 1. Return Type Changes

The main breaking change is that `dynamorm.New()` now returns an interface:

```go
// Before
db, err := dynamorm.New(config) // Returns *dynamorm.DB

// After
db, err := dynamorm.New(config) // Returns core.ExtendedDB
```

### 2. Method Signature Changes

Methods that previously accepted specific option types now accept `...any`:

```go
// Before
db.CreateTable(model, schema.TableOption...)
db.AutoMigrateWithOptions(model, schema.AutoMigrateOption...)

// After
db.CreateTable(model, ...any)
db.AutoMigrateWithOptions(model, ...any)
```

## Migration Guide

### Step 1: Update Imports

Add the core package import where needed:

```go
import (
    "github.com/pay-theory/dynamorm"
    "github.com/pay-theory/dynamorm/pkg/core"  // Add this
)
```

### Step 2: Update Variable Declarations

#### Option A: Use Interfaces (Recommended)

```go
// Change this:
var db *dynamorm.DB

// To this (for full functionality):
var db core.ExtendedDB

// Or this (for basic operations):
var db core.DB
```

#### Option B: Type Assertion (Quick Fix)

If you need the concrete type temporarily:

```go
dbInterface, err := dynamorm.New(config)
if err != nil {
    return err
}

// Type assert to get concrete type
db, ok := dbInterface.(*dynamorm.DB)
if !ok {
    return errors.New("failed to get concrete DB type")
}
```

### Step 3: Update Function Signatures

Update functions that accept or return DB instances:

```go
// Before
func NewService(db *dynamorm.DB) *Service {
    return &Service{db: db}
}

// After (recommended)
func NewService(db core.DB) *Service {
    return &Service{db: db}
}
```

### Step 4: Handle Option Types

If you're using specific option types, ensure proper type conversion:

```go
// The interface accepts ...any but validates at runtime
err := db.CreateTable(model, 
    schema.WithBillingMode(types.BillingModePayPerRequest),
    schema.WithTags(tags),
)
// Runtime validation ensures only valid options are accepted
```

## Benefits of the New Design

### 1. Unit Testing Made Easy

```go
// Mock implementation
type MockDB struct {
    mock.Mock
}

func (m *MockDB) Model(model any) core.Query {
    args := m.Called(model)
    return args.Get(0).(core.Query)
}

// Test with mock
func TestUserService(t *testing.T) {
    mockDB := new(MockDB)
    mockQuery := new(MockQuery)
    
    mockDB.On("Model", &User{}).Return(mockQuery)
    mockQuery.On("Where", "ID", "=", "123").Return(mockQuery)
    mockQuery.On("First", mock.Anything).Return(nil)
    
    service := NewUserService(mockDB)
    user, err := service.GetUser("123")
    
    assert.NoError(t, err)
    mockDB.AssertExpectations(t)
}
```

### 2. Better Separation of Concerns

- Use `core.DB` for services that only need basic operations
- Use `core.ExtendedDB` when you need schema management
- Clearer distinction between data access and schema management

### 3. Dependency Injection

The interface-based design makes dependency injection frameworks work seamlessly:

```go
// With a DI container
container.Register(func() core.DB {
    db, _ := dynamorm.NewBasic(config)
    return db
})
```

## Common Migration Scenarios

### Scenario 1: Lambda Functions

```go
// Before
func handler(ctx context.Context) error {
    db, err := dynamorm.NewLambda(config)
    // db is *LambdaDB which embeds *dynamorm.DB
}

// After
func handler(ctx context.Context) error {
    db, err := dynamorm.NewLambda(config)
    // db is *LambdaDB which embeds core.ExtendedDB
    
    // If you need specific Lambda methods, type assert:
    lambdaDB, ok := db.(*dynamorm.LambdaDB)
}
```

### Scenario 2: Test Helpers

```go
// Before
func setupTestDB(t *testing.T) (*dynamorm.DB, func()) {
    db, err := dynamorm.New(testConfig)
    // ...
}

// After
func setupTestDB(t *testing.T) (core.ExtendedDB, func()) {
    db, err := dynamorm.New(testConfig)
    // ...
}
```

### Scenario 3: Repository Pattern

```go
// Before
type UserRepository struct {
    db *dynamorm.DB
}

// After (recommended)
type UserRepository struct {
    db core.DB  // Use interface for better testability
}

func NewUserRepository(db core.DB) *UserRepository {
    return &UserRepository{db: db}
}
```

## Troubleshooting

### Issue: "cannot use db (variable of type core.ExtendedDB) as *dynamorm.DB"

**Solution**: Update the function to accept the interface type or use type assertion if you need the concrete type.

### Issue: "invalid option type" errors

**Solution**: Ensure you're passing the correct option types. The runtime validation will catch incorrect types:

```go
// This will error at runtime:
db.CreateTable(model, "invalid string option")

// This is correct:
db.CreateTable(model, schema.WithBillingMode(types.BillingModePayPerRequest))
```

### Issue: Transaction type assertions

**Solution**: In transaction callbacks, use type assertion:

```go
err := db.TransactionFunc(func(tx any) error {
    txTyped := tx.(*transaction.Transaction)
    return txTyped.Create(&item)
})
```

## Best Practices

1. **Use Interfaces in Business Logic**: Always use `core.DB` or `core.ExtendedDB` interfaces in your business logic for better testability.

2. **Choose the Right Interface**: 
   - Use `core.DB` for services that only perform CRUD operations
   - Use `core.ExtendedDB` when you need schema management

3. **Mock Strategically**: Create reusable mock implementations that can be shared across tests.

4. **Gradual Migration**: You don't need to migrate everything at once. Start with new code and migrate existing code as needed.

## Full Example

```go
package main

import (
    "log"
    
    "github.com/pay-theory/dynamorm"
    "github.com/pay-theory/dynamorm/pkg/core"
)

type UserService struct {
    db core.DB
}

func NewUserService(db core.DB) *UserService {
    return &UserService{db: db}
}

func (s *UserService) GetUser(id string) (*User, error) {
    var user User
    err := s.db.Model(&User{}).
        Where("ID", "=", id).
        First(&user)
    return &user, err
}

func main() {
    // For production
    db, err := dynamorm.NewBasic(dynamorm.Config{
        Region: "us-east-1",
    })
    if err != nil {
        log.Fatal(err)
    }
    
    service := NewUserService(db)
    user, err := service.GetUser("123")
    if err != nil {
        log.Fatal(err)
    }
    
    log.Printf("User: %+v", user)
}
```

## Resources

- [Testing Guide](../guides/testing.md)
- [Mock Examples](../guides/testing-mock-example.md)
- [Interface Reference](../reference/interfaces.md)

## Support

If you encounter any issues during migration:

1. Check the [Migration Guide](#migration-guide) above
2. Review the [Troubleshooting](#troubleshooting) section
3. Open an issue on [GitHub](https://github.com/pay-theory/dynamorm/issues)

## Acknowledgments

This release was made possible by community feedback requesting better testability. Special thanks to all contributors who helped shape this improvement. 